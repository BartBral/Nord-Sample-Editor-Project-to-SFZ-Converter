<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nord Sample Editor Project to SFZ Converter</title>
<style>
body { font-family: Arial, sans-serif; margin: 2em; }
#feedback { margin: 1em 0; background: #f9f9f9; border: 1px solid #ccc; padding: 1em; white-space: pre-line; }
textarea#sfzPreview {
  width: 100%;
  max-width: 900px;
  height: 400px;
  font-family: monospace;
  white-space: pre;
  resize: vertical;
  border: 1px solid #ccc;
  padding: 0.5em;
  box-sizing: border-box;
  margin-bottom: 0.5em;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
</style>
</head>
<body>

<h2>Nord Sample Editor Project to SFZ Converter</h2>
<p>
  <input type="file" id="fileInput" accept=".nsmpproj,text/plain" />
</p>

<div id="feedback"></div>

<h3>Generated SFZ Preview:</h3>
<textarea id="sfzPreview" readonly></textarea>

<p>
  <button id="downloadBtn" disabled>Download SFZ</button>
  <button id="copyBtn" disabled>Copy SFZ to Clipboard</button>
</p>

<script>
const fileInput = document.getElementById('fileInput');
const downloadBtn = document.getElementById('downloadBtn');
const copyBtn = document.getElementById('copyBtn');
const feedbackDiv = document.getElementById('feedback');
const sfzPreview = document.getElementById('sfzPreview');

let sfzText = null;
let inputFileName = null;

function midiToNoteName(midi) {
  const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  if (typeof midi !== 'number' || midi < 0 || midi > 127) return '?';
  return names[midi % 12] + (Math.floor(midi / 12) - 1);
}

fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  inputFileName = file.name;
  const reader = new FileReader();
  reader.onload = () => {
    const loadedText = reader.result;
    feedbackDiv.textContent = 'Converting...';
    try {
      sfzText = convertNordProjectToSFZ(loadedText);
      const regionCount = (sfzText.match(/<region>/g) || []).length;
      feedbackDiv.innerHTML =
        `Loaded: <b>${inputFileName}</b> (${loadedText.length} bytes)<br>` +
        `Converted: <b>${regionCount}</b> regions.<br>` +
        (regionCount === 0
          ? '<span style="color:#b00">No regions detected, check file format.</span>'
          : '<span style="color:#080">Conversion successful!</span>');
      sfzPreview.value = sfzText;
      copyBtn.disabled = regionCount === 0;
      downloadBtn.disabled = regionCount === 0;
    } catch (err) {
      feedbackDiv.innerHTML =
        `<span style="color:#b00">Error: ${err.message}</span>`;
      sfzPreview.value = '';
      copyBtn.disabled = true;
      downloadBtn.disabled = true;
    }
  };
  reader.readAsText(file);
});

copyBtn.addEventListener('click', () => {
  if (!sfzText) return;
  sfzPreview.select();
  document.execCommand('copy');
  copyBtn.textContent = 'Copied!';
  setTimeout(() => copyBtn.textContent = 'Copy SFZ to Clipboard', 2000);
});

downloadBtn.addEventListener('click', () => {
  if (!sfzText) return;
  const blob = new Blob([sfzText], {type:'application/octet-stream'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = inputFileName.replace(/\.nsmpproj$/i, '') + '.sfz';
  a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
});

function parseNsmpproj(text) {
  const lines = text.split(/\r?\n/);
  const root = { children: [] };
  const stack = [];
  let current = root;
  for (let line of lines) {
    line = line.trim();
    if (!line || line.startsWith('//')) continue;
    if (line.endsWith('{')) {
      const block = { type: line.replace('{','').trim(), props:{}, children:[] };
      current.children.push(block);
      stack.push(current);
      current = block;
    } else if (line === '}') {
      current = stack.pop();
    } else {
      const [k,...v] = line.split('=');
      let val = v.join('=').trim();
      if (val.startsWith('"') && val.endsWith('"')) val = val.slice(1,-1);
      const num = parseFloat(val);
      current.props[k.trim()] = (!isNaN(num) && val === num.toString()) ? num : val;
    }
  }
  return root;
}

function collectBlocks(node,type){
  let arr=[];
  if(node.type===type) arr.push(node);
  for(const ch of (node.children||[])) arr=arr.concat(collectBlocks(ch,type));
  return arr;
}

function convertNordProjectToSFZ(text){
  const root=parseNsmpproj(text);
  const audioFiles=collectBlocks(root,'audio_file').map(b=>b.props);
  const commonZones=collectBlocks(root,'common_zone');
  const instrumentZones=collectBlocks(root,'instrument_zone');
  const mapZones=collectBlocks(root,'map_zone');
  const audioFileById=new Map(audioFiles.map(a=>[a.m_id,a.m_fullName]));
  const commonStrokeByGlobal=new Map();
  for(const cz of commonZones){
    for(const cs of (cz.children||[])){
      if(cs.type==='common_stroke'&&cs.props.m_globalID!==undefined)
        commonStrokeByGlobal.set(cs.props.m_globalID,cs.props);
    }
  }
  const instByZone=new Map();
  for(const iz of instrumentZones){
    const strokes=(iz.children||[]).filter(c=>c.type==='instrument_stroke'&&c.props.m_globalID!==undefined).map(c=>c.props);
    instByZone.set(iz.props.m_zoneId,strokes);
  }
  const mapZoneById=new Map();
  for(const mz of mapZones){
    const strokes=(mz.children||[]).filter(c=>c.type==='map_stroke'&&c.props.m_isEnabled===1).map(c=>c.props);
    mapZoneById.set(mz.props.m_zoneId,{zone:mz.props,strokes});
  }

  let regions=[];
  for(const [zoneId,strokes] of instByZone.entries()){
    const mapEntry=mapZoneById.get(zoneId);
    if(!mapEntry) continue;
    for(const stroke of strokes){
      const cs=commonStrokeByGlobal.get(stroke.m_globalID);
      if(!cs) continue;
      const sampleFile=audioFileById.get(cs.m_fileID)||'unknown.wav';
      const mapStroke=mapEntry.strokes.find(ms=>ms.m_globalID===stroke.m_globalID);

      const lokey=Math.floor(mapEntry.zone.m_btmNote??NaN);
      const hikey=Math.floor(mapEntry.zone.m_topNote??NaN);
      const center=Math.floor(mapEntry.zone.m_rootKey??NaN);
      const tune=Math.floor(mapStroke?.m_detune??0);
      const offset=Math.floor(cs.m_start??NaN);
      const end=Math.floor(cs.m_stop??NaN);

      let loopStart, loopEnd, loopCrossfade, loopMode, loopType;
      let loopVersionComment='';

      if(cs.m_loopEnabled===1){
        let lenRaw, xfRaw;
        if(cs.m_shortLoopEnabled===1){
          lenRaw=cs.m_loopLengthShort;
          xfRaw=cs.m_loopXFadeShort;
          loopVersionComment='// short-loop used';
        } else {
          lenRaw=cs.m_loopLengthLong;
          xfRaw=cs.m_loopXFadeLengthLong;
          loopVersionComment='// long-loop used';
        }
        const startRaw=cs.m_loopStart;
        loopStart=(startRaw!==undefined&&!isNaN(Number(startRaw)))?Math.floor(Number(startRaw)):undefined;
        loopEnd=(loopStart!==undefined&&lenRaw!==undefined&&!isNaN(Number(lenRaw)))?Math.floor(loopStart+Number(lenRaw)-1):undefined;
        if(loopEnd!==undefined&&end!==undefined&&loopEnd>end) loopEnd=end;
        loopCrossfade=(xfRaw!==undefined&&!isNaN(Number(xfRaw))&&Number(xfRaw)>0)?Math.floor(Number(xfRaw)):undefined;
        loopMode='loop_continuous';
        loopType='forward';
      } else {
        loopMode='no_loop';
      }

      regions.push({
        pitchKeycenter:center,
        lokey:isNaN(lokey)?undefined:lokey,
        hikey:isNaN(hikey)?undefined:hikey,
        sampleFile,
        offset:isNaN(offset)?undefined:offset,
        end:isNaN(end)?undefined:end,
        tune,
        loopStart,
        loopEnd,
        loopCrossfade,
        loopType,
        loopMode,
        loopVersionComment
      });
    }
  }

  regions.sort((a,b)=>(a.pitchKeycenter??999)-(b.pitchKeycenter??999));

  let sfz='<group>\n';
  for(const r of regions){
    // Comment indicating if short or long loop used (or empty)
    if(r.loopVersionComment) sfz+=r.loopVersionComment + '\n';

    sfz+=`<region>  // ${midiToNoteName(r.lokey??0)}-${midiToNoteName(r.hikey??0)}\n`;
    sfz+=`sample=${r.sampleFile}\n`;
    if(r.offset!==undefined&&r.end!==undefined) sfz+=`offset=${r.offset} end=${r.end}\n`;
    else {
      if(r.offset!==undefined) sfz+=`offset=${r.offset}\n`;
      if(r.end!==undefined) sfz+=`end=${r.end}\n`;
    }
    if(r.pitchKeycenter!==undefined) sfz+=`pitch_keycenter=${r.pitchKeycenter}\n`;

    let keyRange=[];
    if(r.lokey!==undefined) keyRange.push(`lokey=${r.lokey}`);
    if(r.hikey!==undefined) keyRange.push(`hikey=${r.hikey}`);
    if(keyRange.length) sfz+=keyRange.join(' ')+'\n';

    sfz+=`tune=${r.tune}\n`;

    if(r.loopMode==='loop_continuous'){
      if(r.loopStart!==undefined)
        sfz+=`loop_start=${r.loopStart}  // m_loopStart\n`;
      if(r.loopEnd!==undefined)
        sfz+=`loop_end=${r.loopEnd}  // m_loopStart + m_loopLength${r.loopVersionComment.includes('short')?'Short':'Long'} - 1\n`;
      if(r.loopCrossfade!==undefined)
        sfz+=`loop_crossfade=${r.loopCrossfade}  // m_loopXFade${r.loopVersionComment.includes('short')?'Short':'LengthLong'}\n`;
      if(r.loopType!==undefined)
        sfz+=`loop_type=${r.loopType}\n`;
      sfz+=`loop_mode=${r.loopMode}\n`;
    }
    sfz+='\n';
  }
  return sfz;
}
</script>

</body>
</html>
